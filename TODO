Rough plan/ideas

Once something is done it is moved to history.htm.

Items marked LibPkg: will need work done in the LibPkg backend library as well.

I'm currently thinking of a couple of point release to get a few of the more minor improvements in.


Web pages updates
-----------------
Hopefully I can get time to fix some of the Packaging web pages
www.riscos.info
 - Make sure there is an entry for PackMan and add link to it to RiscPkg page
 - GCCSDK pages link to PackMan not RiscPkg as it won't do the latest packages
www.riscosopen.info
 - check packages pages
My site
 - Add a draft policy manual? Graham doesn't seem to have updated the main one yet

Version 0.8.x
-------------

- Install filter doesn't update with new packages after an install
- Add Install/Upgrade/Remove button to the Info window (User request, but I don't remember who)
- Add Copyright and View (components) button to the Info window.
- Add way to save list of what's installed so it can be used to restore a machine or set up another machine with the same packages (Jess Hampshire) - see below
- Save position on main window menu to remember package window location
- Take description display from summary bar and put in child window above summary that can be resize by dragging something at the top edge.
- Could the filter in PackMan make a distinction between filtering on section vs filtering a status (Installed etc)? At its simplest this could be just a separator in the menu but it the filter could also be split up. Eg to filter out upgrades in the Desktop section. (from Fred Graute)
- After failure to commit should I reshow the configure window or clear all the entries?
- Commit failure may be leaving Components file which shouldn't be there - need to test
- LibPkg: Doesn't successfully "download" a file from the local disc if it's over 64K

Version 0.9
-----------

More major release which include new LibPkg standards version
- Run scripts during install remove (see below) - only aiming to do PreRemove/PostInstall for now
- Implement Hold functionality from LibPkg to stop a package being upgraded


For versions after 0.9
----------------------

- See why a failed install means you can't install anything new without the failed package turning up in the dependencies list.
- Check if netsurf builds still exists.
- Implement Purge functionality. I need to double check what this means, but if it means remove the package from the Package database then it could be very useful.

Things to check
---------------

- Sources window should not allow a second Update Lists window to be run.
- Check progress bar in update lists. Was 100% when it still had more to do.
- I thought get list failure had a more useful error message stating the list name - it didn't appear to when I had a problem recently.
- Got a crash on KnownSources when the html file was missing


Possible future changes (i.e. under consideration)
--------------------------------------------------

- Scroll bars on conflicts window
- Scroll bars on package configuration window so the full description of components can be shown.
- For Drag and drop give the choice of creating a stub instead of setting the install location (from Jess Hampshire).
- Cancel processing during install/remove
- Adjust on install does an immediate install (from Jess Hampshire)
- Download other list on timeout (from Grahame Parish)
  I have three sources set and if any one of them is unavailable then no updates can be applied from any of the other sources. It would be useful to timeout a connection to a source and skip to the next one.  The only way round this is to remove the source from the list and update lists again, but it's not ideal (the New Sources list in 0.7.x should make enabling/disabling easier)
- Automatic run update lists - ask if you want to upgrade and optionally exit (from Jess Hampshire).
- Verify individual packages (the Verify All seems fairly quick so this may not be required).
- Add option to check (verify should be added to 0.7.x/0.8), repair or re-install packages (Jess Hampshire)
- Previous versions - theoretically LibPkg can handle this. I would have to make sure.
- The information in in the main window is difficult to read, because its text colour is almost the same as the background colour. I would prefer to see black on white, and the same font as in the  main panel. Also, because the text doesn't wrap, and the width of the panel is fixed, information is lost at the right hand side.  (from Tony Moore).
- When upgrading check if the old version has been moved and prompt for it's location if it has.
- Consider how to let PackMan know if an application has been moved from outside of PackMan.
- With local install show dialogue to allow any unmet dependencies to be dragged into it.
- Export Package - create a package containing a package and all it's dependencies.
- Package file format get file type for Packages.
- Possibly allow a package file to contain multiple packages.
- Possibly allow a package file be a stub package to tell PackMan to download something.
- Expert mode - give options to install even when dependencies are missing or there are conflicts.
- Multiple sections/categories.
- Better error if Status file is corrupt when loading packages database (Fred Graute)
- Or preferably more robust handling of Status file if it's missing tabs as it can when hand edited. Possibly by always putting something (e.g. 'User') in the last field. (Fred Graute)


Components (now in 0.8 - delete from here when Policy Manual is updated)
------------------------------------------------------------------------

To support setting the install location, defaults for LookAt and other things in future I'm going to add a new field to the control record.

The policy manual entry will be:

The 'Components' field

This contains a comma-separated list of the components that have extra configuration options.

components-list = [ component-details, { [ws], ',', [ws], component-details } ]

The component-details consists of the the component file/folder name and its options.

component-details = file-name, [ws], component_options ;
component-options = '(', { [ws], component_option {[ws] ',' component-option } ,[ws], ')'

component-option = 'Moveable' , 'LookAt' ;

'Moveable' means that this component can be installed to a different location or moved after install.

'LookAt' means that this component suggests that it will be looked at on booting. i.e. It is added to the !Boot options 'Look At' list. At install time the user will be able to override this suggestion. As a guideline this flag should only be set for components that are run by double clicking on a file type or command line utilities.

For example:

Components: Apps.Development.!PackIt (Moveable,LookAt)


Future options may include
 'Font' install as a RISC OS font.
 'SysMerge' This component is a system module so use sys merge logic to update it (e.g. If a new version of the module has been installed update the package version, but leave the existing module in place).


System Module checking (plan to add in 0.8.1)
---------------------------------------------

Module checking details, after downloading a package that contains a single module, control files and optionally documentation in the Manuals path, libpkg will now check if an existing RISC OS module is installed at the same location.
If the module if found and an older version, the package will overwrite it.
If the module found is the same or greater than the package version it will be left in place and the package database updated with the found version.
The module versions found already on the machine are always assumed to have a "-1" on the end for the package version, so using "-2" or greater on a package will mean the same version is overwritten.


Save/Restore installed package lists
------------------------------------

Only include installed packages (auto installed is expected to be picked up in normal processing)

Simple xml format
<packmanlist version="1">
  <sources>
    <source url = "..." />
    ...
  </sources>
  <packages>
    <package name = "..." version = "...">
      <component name = "..." path = "..." <lookat> <run> <addtoapps> />
      ...
    </package>
    ...
  </packages>
  
Saving
- Menu Advanced "Installed List..."
  - Show list of packages to install and allow selection of ones to include
  - Check box for don't include paths
  - Check box for don't include sources
  - Draggable to drag to save the list
  
Loading
- Drag list to iconbar icon
  - Remove packages already installed, sources already selected and paths changed locally.
  - Show details of list (packages, paths and sources)
  - Allow selection of packages to include
  - Allow selection of paths to add
  - Allow selection of sources to add
  - Check if packages required are in currrent list, if not prompt for update lists after adding sources
  - Check paths added are available - if not give chance to map to somewhere else.


Install/Remove code
-------------------

The idea here is to provide scripts that can be run during the installation/removal process when required. I still haven't managed to figure this out yet and where in the process they need to go, but they will need changes to the LibPkg backend.

Having expermented with LUA in another project I'm wondering if I should use that instead.

My current thoughts/things to sort out are:
- Copied from debian installs there are four scripts that can be run prerm, postrm, preinst, postinst.
- In LibPkg instead of scripts they can be any runnable filetype. This will allow BASIC to be used for instance.
- LibPkg will probably need to ask the front end to run them and report when they are finished. My current thoughts are they should be run using Wimp StartTask in a taskwindow. Maybe LibPkg should fall back to system calls so it could theoretically be used in a command line utility.
- Before each script a set of variable for the package will need to be defined. Things like LibPkg$Pkg$NewVersion, LibPkg$Pkg$Target1..N for the various directories. At the end the script would set LibPkg$Pkg$error if something went wrong. This still needs some thought.
- Upgrade handling - this probably needs to call the old prerm and postrm, but the new preinst and postinst and probably needs parameters so the scripts can see it's an upgrade.
- Failure handling - what get's called when unwinding.

My latest idea is to do PreRemove/PostInstall only as they can be run without having to mess about saving things

LibPkg changes

- New directory RiscPkg.Config contains configuration code.
  - PreRemove file is run before a file is removed or upgraded
  - PostInstall file is run after a file is installed, upgraded or when unwinding a failed install if PreRemove was run.
  
- During intial stages add list of config structures with the following fields
  - Package name
  - Action (Install/Upgrade/Remove)
  - Remove version (not set for install)
  - Install version (not set for remove)
  - Has remove been run (set after remove script is run)
  - map of component names to install location
  
- After initial checks (i.e. do downloads and file conflicts first) run any PreRemove code
  - New commit stage "preremove"
  - For each package check for file RiscPkg.Config.PreRemove and if exists do the following:
    - Code is run by front end via new config_run interface using TaskWindow -wimpslot 512K -quit "..."
    - Code called as PreRemove <Remove|Upgrade> <install version if upgrade>
    - Before run following env variables are set
      - LibPKG$CFG_ACTION = Remove|Upgrade
      - LibPKG$CFG_REMOVE_VERSION
      - LibPKG$CFG_INSTALL_VERSION
      - LibPKG$CFG_PATH_... = ... Each component in package will have its location on disk made available
      - LibPKG$CFG_RESULT = -2    -2 means code failed to run
    - On exit the code must update LibPKG$CFG_RESULT as follows
      - -1 Error
      - 0 OK
      - 1 Note (add note to new window shown after commit)
      - 2 Warning (add warning to new window shown after commit)
      If result is <> 0, must also set LibPKG$CFG_MESSAGE to message to be added to the notes window
    - If result < 0 then configuration failed, jump to unwind preremove stage
  
- After all file have been copied and booted etc run any PostInstall scripts
  - New commit stage post install.
  - For each package check for file RiscPkg.Config.PostInstall and if exists do the following
    - Code is run by front end via new config_run interface using TaskWindow -wimpslot 512K -quit "..."
    - Code called as PostInstall <Install|Upgrade> <remove version if upgrade>
    - Before run following env variables are set
      - LibPKG$CFG_ACTION = Install|Upgrade
      - LibPKG$CFG_REMOVE_VERSION
      - LibPKG$CFG_INSTALL_VERSION
      - LibPKG$CFG_PATH_... = ... Each component in package will have its location on disk made available
      - LibPKG$CFG_RESULT = -2    -2 means code failed to run
    - On exit the code must update LibPKG$CFG_RESULT as follows
      - -1 Error
      - 0 OK
      - 1 Note (add note to new window shown after commit)
      - 2 Warning (add warning to new window shown after commit)
      If result is <> 0, must also set LibPKG$CFG_MESSAGE to message to be added to the notes window
    - Error result does not cause an unwind, it just adds a message to the new post commit window
    
- If package is unwound due to an error
  - new stage unwind_preremove
  - For each package where remove code was called call PostInstall as follows
    - Code is run by front end via new config_run interface using TaskWindow -wimpslot 512K -quit "..."
    - Code called as PostInstall <Abort-Upgrade|Abort-Remove> <remove version if upgrade>
    - Before run following env variables are set
      - LibPKG$CFG_ACTION = Abort-Upgrade|Abort-Remove
      - LibPKG$CFG_REMOVE_VERSION
      - LibPKG$CFG_INSTALL_VERSION
      - LibPKG$CFG_PATH_... = ... Each component in package will have its location on disk made available
      - LibPKG$CFG_RESULT = -2    -2 means code failed to run
    - On exit the code must update LibPKG$CFG_RESULT as follows
      - -1 Error
      - 0 OK
      - 1 Note (add note to new window shown after commit)
      - 2 Warning (add warning to new window shown after commit)
      If result is <> 0, must also set LibPKG$CFG_MESSAGE to message to be added to the notes window
    - Error result adds a message to the new post commit window
    
- After commit finished (success or failure)
  - If any messages from config code show post commit window displaying them.

Extra Notes:

I'm hoping this will be enough for most apps, but in case it isn't the following names are
reserved PreInstall, PostRemove, PreMove, PostMove.
Also if PreInstall is implemented PostInstall may receive a new action "Abort-Install"

The code will need to be run by the front end application as it should be run in a TaskWindow
LibPkg will include an new interface pkg::config_run

The interface will contain one method

virtual bool run_config_code(std::string path_to_code)
This should return false if it fails to start the code

If it starts OK, the task window should be monitored and the following methods called in pkg::commit
void config_code_failed() - TaskWindow failure after initial startup
void config_code_output(std::string text) - Any output from the configuration script should be sent to the commit window which will add it to the log if logging is on
void config_code_finished() - Called when config code has finished and task has completed.

The implementation of this interface should be passed to the commit class as it is created.


LibPkg logging
--------------

The idea here is to add logging so that it is easier to figure out what is happening when creating a new package that for some reason isn't working.

Lastest log idea

- log is just built in memory and view log button is added to component window (this window should allow the log to be saved)
- log entry consists of an id and zero or more parameters
- ids specify type 10000-19999 errors, 20000-29999 runtime warnings, 30000-39999 invalid package warnings, 40000-49999 Information.
- each log entry should have the time and date it was added.
- maintains a count of errors and warnings, so warnings can be brought to attention after action.

so logging lines will be something like:
  log().log(log::INFO_DOWNLOADS_STARTED);
  log().log(log::ERROR_FILE_COPY_FAILED, file_name, except.what());


Previous log idea

It could also be used as a history of whats done.

The log will be written to <Packages$Dir>.Log

A single flag will control if logging is no or off.

Additional flags will control what is logged when logging is on
- Errors in installation will always be logged.
- Package - just log package installed/removed
- Package details - log unpacking etc/steps
- file processes - copying/deleting files etc.
- file io - low level OS file call results.
- lists - log whenever the lists are updated
- list details - log download of each list

Each log entry should have the time and date it was written.

A new Window will be added to PackMan to allow logging options to be set, open and delete the log.
