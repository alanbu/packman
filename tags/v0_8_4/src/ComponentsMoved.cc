/*
 * ComponentsMoved.cc
 *
 *  Created on: 22 Oct 2013
 *      Author: alanb
 */

#include "ComponentsMoved.h"

#include "Packages.h"
#include "tbx/application.h"
#include "libpkg/pkgbase.h"
#include "libpkg/component.h"
#include "libpkg/boot_options_file.h"

/**
 * Constructor calculate the list of components that may be moved.
 *
 * This should be called before the paths table is altered
 *
 * @param path_to_move path that is going to be moved
 */
ComponentsMoved::ComponentsMoved(tbx::Path path_to_move) :
   _poll_total(3), _poll_count(0)
{
	// Build list of installed components whose path is equal to contained in path_to_move
   pkg::pkgbase *package_base = Packages::instance()->package_base();
   const pkg::status_table& curstat = package_base->curstat();
   const pkg::binary_control_table& ctrltab = package_base->control();
   pkg::path_table &paths = Packages::instance()->package_base()->paths();

   path_to_move.canonicalise();
   int path_to_move_len = path_to_move.name().size();

   for (pkg::status_table::const_iterator i=curstat.begin();
	 i !=curstat.end(); ++i)
   {
		if ((*i).second.state() == pkg::status::state_installed)
		{
			const pkg::binary_control &ctrl = ctrltab[i->first];
			std::string comp_str = ctrl.components();
			if (!comp_str.empty())
			{
				std::vector<pkg::component> comps;
				pkg::parse_component_list(comp_str.begin(), comp_str.end(), &comps);
				for (std::vector<pkg::component>::iterator c = comps.begin(); c != comps.end(); ++c)
				{
					if (c->flag(pkg::component::movable))
					{
						tbx::Path comp_path(paths(c->name(), ""));
						comp_path.canonicalise();
						int comp_len = comp_path.name().size();
						if (path_to_move.name().compare(0, path_to_move_len, comp_path.name()) == 0
							&& (comp_len == path_to_move_len || comp_path.name()[comp_len] == '.'))
						{
						   _components.push_back(CompInfo(c->name(), comp_path));
						}
					}
				}
			}
		}
   }

   _state = UPDATE_BOOT_OPTIONS;
   _warning = NO_WARNING;
}

ComponentsMoved::~ComponentsMoved()
{
}

/**
 * Check if any of the components from the constructor have
 * need to be updated.
 *
 * Call after the paths table has been altered.
 */
void ComponentsMoved::check_if_moved()
{
	if (_components.empty()) return; // Nothing to do

	pkg::path_table &paths = Packages::instance()->package_base()->paths();
	std::vector<CompInfo>::iterator c = _components.begin();

	while (c != _components.end())
	{
		c->new_path = paths(c->logical_path, "");
		c->new_path.canonicalise();
		if (c->current_path.name() == c->new_path.name())
		{
			// Path hasn't changed so remove
			c = _components.erase(c);
		} else
		{
			++c;
		}
	}

	// Maximum polls generated by this number of components
	_poll_total = 3 + _components.size() * 2; // Each stage, booting and add to apps
}

/**
 * Poll to update the settings for moved components
 *
 * Poll until state() == DONE
 */
void ComponentsMoved::poll()
{
	switch(_state)
	{
	case UPDATE_BOOT_OPTIONS:
		{
			// Update boot options
			try
			{
				pkg::look_at_options look_at;

				for (std::vector<CompInfo>::iterator c = _components.begin(); c != _components.end(); ++c)
				{
					if (look_at.replace(c->current_path.name(), c->new_path.name()))
					{
						_files_to_boot.insert(c->new_path.name());
					}
				}

				look_at.commit();

				pkg::run_options run;
				for (std::vector<CompInfo>::iterator c = _components.begin(); c != _components.end(); ++c)
				{
					if (run.replace(c->current_path.name(), c->new_path.name()))
					{
						// Don't run this time, but make sure the new location is booted
						_files_to_boot.insert(c->new_path.name());
					}
				}
				run.commit();

				pkg::add_to_apps_options add_to_apps;
				for (std::vector<CompInfo>::iterator c = _components.begin(); c != _components.end(); ++c)
				{
					if (add_to_apps.replace(c->current_path.name(), c->new_path.name()))
					{
						// Re run add to apps to move them
						_files_to_add_to_apps.insert(c->new_path.name());
					}
				}
				add_to_apps.commit();
			} catch(...)
			{
				_warning = BOOT_OPTIONS_UPDATE_FAILED;
			}

			// More accurate poll total
			_poll_total = 3 + _files_to_boot.size() + _files_to_add_to_apps.size();

			_state = BOOT_FILES;
		}
		break;

	case BOOT_FILES:
	    if (_files_to_boot.size())
		{
			std::string file_to_boot = *_files_to_boot.begin();
			try
			{
				// Can't use Filer_Boot as it does nothing if the task is already seen
				// so use Filer_Run on the !Boot file.
				tbx::Path boot_file(file_to_boot, "!Boot");
				if (boot_file.exists())
				{
				   std::string command("Filer_Run ");
				   command += boot_file.name();
				   tbx::app()->os_cli(command.c_str());
				}
			} catch(...)
			{
				if (_warning == NO_WARNING) _warning = BOOTING_FAILED;
			}
			_files_to_boot.erase(file_to_boot);
		} else
		{
			// Progress to next state.
			_state = ADD_FILES_TO_APPS;
		}
		break;

	case ADD_FILES_TO_APPS:
		if (_files_to_add_to_apps.size())
		{
			std::string file_to_add = *_files_to_add_to_apps.begin();
			try
			{
				std::string command("AddApp ");
				command += file_to_add;
				tbx::app()->os_cli(command.c_str());
			} catch(...)
			{
				_warning = ADDING_TO_APPS_FAILED;
			}
			_files_to_add_to_apps.erase(file_to_add);
		} else
		{
			// Progress to next state.
			_state=DONE;
		}
		break;

	case DONE:
		// Nothing to do - should no longer be polled
		break;
	}
}

